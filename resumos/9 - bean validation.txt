9.1 - 

Bean Validation é uma especificação que faz parte do JEE.
Validação de propriedades.

ex:

@NotNull
@Size(min=3, max=50)
@Email

OBS:
como o bean validation é apenas uma especificação precisamos de uma implementação para usa- lo. O projeto Hibernate Validator é a implementação de referencia da implementação.


Adicionando dependencia: validation

9.2. Adicionando constraints e validando no controller com @Valid

@Valid 			// Fazer a validação da variavel antes de chamar o método

@NotNull                // Não aceita valores Nulos

Exemplo:

Exception lançada: 'MethodArgumentNotValidException'

Entidade:

@NotNull
@Column(nullable=false)
private String nome;

Controller :

@PostMapping
public Restaurante adicionar(@RequestBody @Valid  Restaurante restaurante) {
	try {
		return restauranteService.salvar(restaurante);
	} catch (EntidadeNaoEncontradaException e) {
		throw new NegocioException(e.getMessage());
	}

}

9.3 tratando exception de violação de constraints de validação

@Override
	protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex,
			HttpHeaders headers, HttpStatus status, WebRequest request) {

		ProblemType problemType = ProblemType.DADOS_INVALIDOS;

		String detail = "Um ou mais campos estão inválidos. Faça o preenchimento correto e tente novamente.";

		Problem problem = createProblemBuilder(status, problemType, detail).build();

		return handleExceptionInternal(ex, problem, headers, status, request);

	}

9.4. Estendendo o Problem Details para adicionar as propriedades com constraints violadas

Adicionando mais um atributo na classe Problem

@JsonInclude(Include.NON_NULL)
@Getter
@Builder
public class Problem {
	
	private Integer status;
	private String type;
	private String title;
	private String detail;
	
	private String userMessage;
	private LocalDateTime timestamp;
	
	private List<Field> fields;
	
	@Getter
	@Builder
	public static class Field {
		private String name;
		private String userMessage;
	}
}

Novo método em exceptios

@Override
	protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex,
			HttpHeaders headers, HttpStatus status, WebRequest request) {

		ProblemType problemType = ProblemType.DADOS_INVALIDOS;

		String detail = "Um ou mais campos estão inválidos. Faça o preenchimento correto e tente novamente.";
		
		BindingResult bindingResult = ex.getBindingResult();
		
		List<Problem.Field> problemFields = bindingResult
				.getFieldErrors()
				.stream()
				.map(fieldError -> Problem.Field.builder()
						.name(fieldError.getField())
						.userMessage(fieldError.getDefaultMessage())
						.build()
					)
				.collect(Collectors.toList());
				
		
		Problem problem = createProblemBuilder(status, problemType, detail)
				.fields(problemFields)
				.build();

		return handleExceptionInternal(ex, problem, headers, status, request);

	}


9.5. Conhecendo e adicionando mais constraints de validação no modelo

Constrains:
https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-builtin-constraints

@DecimalMin("0") 	-> o value recebe uma string que pode ser convertida em bigdecimal
@PositiveOrZero  	-> Ou um valor positivo ou Zero, ou seja v <= 0

@NotNull		-> Não aceita valores nulos
@NotBlank 		-> Não aceita valores nulos e vazios e nem espaços em branco
@NotEmpty		-> Não aceita valores vazios


9.6. Validando as associações de uma entidade em cascata

requisição errada:
{
	"nome":"outback",
	"taxaFrete": 1 ,
	"cozinha": null
}


- podemos validar isso com Cozinha @NotNull.
- porém se enviarmos uma cozinha com código nulo, volta a ter erro não resolvido.

- devemos fazer um @NotNull no id de cozinha, porém isso não vai resolver, pois
o bean validation não valida em cascata.
- A não ser que especificamos isso. com o @Valid no atributo :

@Valid 			// valide as propriedades de cozinha
@NotNull		// Cozinha não pode ser um atributo nulo
private Cozinha cozinha;

9.7. Agrupando e restringindo constraints que devem ser usadas na validação







